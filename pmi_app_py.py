# -*- coding: utf-8 -*-
"""pmi_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10NNokAqvf8SiRfevbf707EO29ZrHMoBD
"""

import streamlit as st
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import folium
from streamlit_folium import st_folium # To display folium maps in Streamlit

# --- Streamlit Page Configuration ---
st.set_page_config(layout="wide", page_title="HCP Segmentation Tool")

st.title("Interactive HCP Segmentation Tool (POC)")
st.markdown("""
This tool performs KMeans clustering on HCP data based on transaction count and location.
Upload a CSV file with columns: `hcp id`, `trx count`, `lat`, `long`.
""")

# --- File Upload ---
uploaded_file = st.file_uploader("Choose a CSV file", type="csv")

if uploaded_file is not None:
    try:
        df = pd.read_csv(uploaded_file)
        st.success("File Uploaded Successfully!")

        # --- Data Validation ---
        required_columns = ['hcp id', 'trx count', 'lat', 'long']
        if not all(col in df.columns for col in required_columns):
            st.error(f"Error: CSV must contain the columns: {', '.join(required_columns)}")
        else:
            st.write("### Input Data Preview (First 5 Rows)")
            st.dataframe(df.head())

            # --- Handle Missing Values (Simple Strategy: Drop Rows) ---
            initial_rows = len(df)
            df_cleaned = df.dropna(subset=['trx count', 'lat', 'long']).copy() # Use copy to avoid SettingWithCopyWarning
            rows_dropped = initial_rows - len(df_cleaned)
            if rows_dropped > 0:
                st.warning(f"Warning: Dropped {rows_dropped} rows with missing values in 'trx count', 'lat', or 'long'.")

            if len(df_cleaned) == 0:
                 st.error("Error: No valid data remaining after handling missing values.")
            else:
                # --- User Input for Number of Clusters ---
                k = st.number_input("Select the number of clusters (territories):", min_value=2, max_value=50, value=5, step=1)

                # --- Feature Selection and Scaling ---
                features = ['trx count', 'lat', 'long']
                X = df_cleaned[features]

                scaler = StandardScaler()
                X_scaled = scaler.fit_transform(X)

                # --- KMeans Clustering ---
                if st.button(f"Generate {k} Clusters"):
                    with st.spinner('Performing clustering...'):
                        kmeans = KMeans(n_clusters=k, init='k-means++', random_state=42, n_init=10) # Set n_init explicitly
                        kmeans.fit(X_scaled)
                        df_cleaned['Cluster ID'] = kmeans.labels_

                        st.success(f"Clustering Complete! {k} segments generated.")

                        # --- Display Results ---
                        st.write("### Segmentation Results")

                        # 1. Map Visualization
                        st.write("#### Map Visualization")
                        # Create a base map centered around the mean lat/lon
                        map_center = [df_cleaned['lat'].mean(), df_cleaned['long'].mean()]
                        m = folium.Map(location=map_center, zoom_start=4)

                        # Define a color scheme (simple example)
                        colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred',
                                  'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue',
                                  'darkpurple', 'white', 'pink', 'lightblue', 'lightgreen',
                                  'gray', 'black', 'lightgray']

                        for idx, row in df_cleaned.iterrows():
                            cluster_id = row['Cluster ID']
                            folium.CircleMarker(
                                location=[row['lat'], row['long']],
                                radius=3, # Smaller marker size
                                popup=f"HCP ID: {row['hcp id']}<br>Trx Count: {row['trx count']}<br>Cluster: {cluster_id}",
                                color=colors[cluster_id % len(colors)], # Cycle through colors
                                fill=True,
                                fill_color=colors[cluster_id % len(colors)],
                                fill_opacity=0.7
                            ).add_to(m)

                        # Display the map in Streamlit
                        st_folium(m, width=700, height=500)


                        # 2. Cluster Summary Statistics Table
                        st.write("#### Cluster Summary Statistics")
                        cluster_summary = df_cleaned.groupby('Cluster ID').agg(
                            Number_of_HCPs=('hcp id', 'count'),
                            Average_Trx_Count=('trx count', 'mean'),
                            Geographic_Centroid_Lat=('lat', 'mean'),
                            Geographic_Centroid_Long=('long', 'mean')
                        ).reset_index()
                        cluster_summary = cluster_summary.round(2)
                        cluster_summary['Geographic_Centroid_Lat'] = cluster_summary['Geographic_Centroid_Lat'].round(4)
                        cluster_summary['Geographic_Centroid_Long'] = cluster_summary['Geographic_Centroid_Long'].round(4)
                        st.dataframe(cluster_summary)


                        # 3. Data Table with Cluster IDs
                        st.write("#### Segmented Data Table")
                        st.dataframe(df_cleaned[['hcp id', 'trx count', 'lat', 'long', 'Cluster ID']])

                        # 4. Download Button
                        st.write("#### Download Segmented Data")
                        csv_output = df_cleaned.to_csv(index=False).encode('utf-8')
                        st.download_button(
                            label="Download data as CSV",
                            data=csv_output,
                            file_name=f'hcp_segmented_data_{k}_clusters.csv',
                            mime='text/csv',
                        )

    except Exception as e:
        st.error(f"An error occurred: {e}")
        st.warning("Please ensure the uploaded file is a valid CSV and has the correct format.")

else:
    st.info("Awaiting CSV file upload.")